# Sobre Rust

- Rust usa `snake_case` para las variables, funciones, módulos, y miembros de estructuras; `PascalCase` para tipos de datos complejos (estructuras, enumeraciones, etc.) y alias de tipos; y `UPPER_SNAKE_CASE` para constantes y variables estáticas (esta última siendo no usada en este proyecto)
- Al crear un módulo en Rust, su archivo principal se encuentra en la carpeta con el nombre del módulo, bajo el nombre `mod.rs`, o en un archivo en la misma carpeta del módulo "padre" con el nombre `[nombre del módulo].rs`
- Rust es un lenguaje más basado en datos que en objetos - como una versión de C con más opciones. Por esto mismo, he intentado evitar utilizar métodos para acceder a los datos cuando he podido
- En vez de permitir que todos los tipos de datos (o todos los punteros) sean "nullables", existe `Option<T>`, un wrapper a un tipo existente, que puede ser o `Some(value)` (equivalente a un valor) o `None` (equivalente a null)
- De la misma forma, la propagación de errores se realiza mediante `Result<T, E>`, el cual puede devolver `Ok(valor)` - todo bien - o `Err(error)` - que devuelve el estado del error. Las excepciones como tal no existen excepto con "pánicos", que son estados de emergencia y/o error del programador de los cuales no se puede depender - y bastante difíciles de capturar.
- Todas las variables se definen como no mutables (sólo lectura) o mutables (editables). Las variables/referencias mutables vienen acompañadas de la palabra clave `mut`. No voy a entrar a explicar la complejidad del *borrow checker* de Rust, pero es importante entender por qué, por ejemplo, hay código duplicado en `repository` - en algunos casos se devuelve una referencia inmutable para que el cliente la lea, y en otros, una mutable para modificar, añadir, o eliminar datos.